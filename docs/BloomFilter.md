# BloomFilter

## 原理

一种Hash的高级形式，通过一个或多个位图(bitmap)的重叠来降低单Hash的误差，但仍存在假阳的可能。

直观理解：有一种在数据集报错率为p的hash函数，在N个特征上用N个同样的hash函数去报告某样本是否存在，
则报错率下降至$p^n$。

这种方式做成的hash查询就十分高效，但存在假阳可能，也不支持删除操作。

- 不支持删除？
  - 因为每个样本在bitmap对应的位置只能被置1或0，若置0则表示一定返回NotFound，  
    但置1并不能代表只有单个样本被映射到这个位置，因此删除某样本不能连带将其对应的bitmap置0。
  - 再设置个计数器？
    - 那样就太庞大了，丢掉了它空间占用小的优势。
- 误报？
  - 根据实际使用情况，如果报告Found，再去实际地检索即可。

## 接口

Filter只需要实现构建和查询两个功能，在levelDB中给到了这两个接口

- CreateFilter
- KeyMayMatch

## 最佳哈希函数数量

设定m是bitmap的空格总数，n是待插入并查询的元素总数（一个metaBlock中key的总数），
我们将设计k个哈希函数（或者可以粗暴理解为k个hash叠起来的k维bitmap）

由数学推导（感谢数学家，我就不推导了）可知最低误差率出现在
$k = {bpk} * \ln 2$
处，其中bpk是bits_per_key = $\frac{m}{n}$，

```C++
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
```
